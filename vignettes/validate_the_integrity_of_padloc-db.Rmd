---
title: "Validate the integrity of padloc-db"
author: "Leighton Payne"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Validate the integrity of padloc-db}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = TRUE
)
```

```{r setup}
library(padlocdev)
```

### Example files

This package includes example files for demonstrating functions. These files
can be listed and accessed with the function `padlocdev_example()`. In the
following code, you'll see this function used to access these example files.

```{r, message = FALSE}
# List example files (these are located in the package directory `padlocdev/inst/exdata/`).
padlocdev_example()

# Generate the full path to a specific example file.
padlocdev_example("hmm/PROT00001.hmm")
```

### Reading padloc-db files

You can read single profile HMMs, padloc models, the HMM metadata table, 
system metadata table, and system group information with the following 
functions.

#### Metadata tables

```{r, message = FALSE}
path <- padlocdev_example("hmm_meta.txt")
hmm_meta <- read_hmm_meta(path)
head(hmm_meta)
```

```{r, message = FALSE}
path <- padlocdev_example("sys_meta.txt")
sys_meta <- read_sys_meta(path)
head(sys_meta)
```

```{r, message = FALSE}
path <- padlocdev_example("sys_groups.txt")
sys_groups <- read_sys_groups(path)
head(sys_groups)
```

#### Profile HMMs

```{r, message = FALSE}
path <- padlocdev_example("hmm/PROT00001.hmm")
hmm <- read_hmm(path)
```

You can access the profile HMM information the same as with any list object.

```{r, message = FALSE}
# profile HMMs comprise two elements, header information and model data
names(hmm)
```

```{r, message = FALSE}
names(hmm[["header"]])

# Access a sublist of multiple elements
hmm[["header"]][c("NAME", "ACC", "DESC")]

# Access the value of a single element 
hmm[["header"]][["NAME"]]
```

```{r, message = FALSE}
names(hmm[["model"]])

hmm[["model"]][["match_emissions"]]
```
To read just the header information, use `read_hmm_header()` instead.

```{r, message = FALSE}
hmm_header <- read_hmm_header(path)
names(hmm)
```

#### System models

```{r, message = FALSE}
path <- padlocdev_example("sys/SystemA_I.yaml")
model <- read_padloc_model(path)
```

As above, you can access the the elements of a padloc model the same as any 
list object.

```{r, message = FALSE}
names(model)

model[["core_genes"]]
```

#### Reading multiple files

Wrappers are provided for reading all `sys/*.yaml` and `hmm/*.hmm` files in a 
directory into a list.

```{r, message = FALSE}
# Reading all profile HMMs in a directory.
path <- padlocdev_example("hmm")
hmms <- multi_read_hmm(path)
names(hmms)
```

For larger databases, it's more efficient to just read the header information
of each HMM as we're not interested in the actual model (e.g. `0.51` vs `0.33` 
seconds on this small database).

```{r, message = FALSE}
hmms <- multi_read_hmm_header(path)
```

```{r, message = FALSE}
# Reading all padloc models in a directory.
path <- padlocdev_example("sys")
models <- multi_read_padloc_model(path)
```

### Expanding secondary gene assignments

Before testing model validity, secondary gene assignments need to be expanded.
This can be done for a single gene category for a single system model as
follows.

```{r, message = FALSE}
hmm_meta <- padlocdev_example("hmm_meta.txt") |> read_hmm_meta()
model <- padlocdev_example("sys/SystemA_III.yaml") |> read_padloc_model()

model[["optional_genes"]]

model[["optional_genes"]] <- 
  expand_gene_groups(model, gene_type = "optional_genes", hmm_meta)

model[["optional_genes"]]
```

A wrapper is provided to expand the gene assignments for all gene categories 
of all system models in a list.

```{r, message = FALSE}
hmm_meta <- padlocdev_example("hmm_meta.txt") |> read_hmm_meta()
models <- padlocdev_example("sys") |> multi_read_padloc_model()

models[["SystemA_III"]][["optional_genes"]]

models_expanded <- expand_gene_groups_all(models, hmm_meta)

models_expanded[["SystemA_III"]][["optional_genes"]]

```

### Checking that system models are valid

`valid_padloc_model_basic()` and `valid_padloc_model_expanded()` are used for
assessing model validity. Each function provides useful error information for
fixing a model if it appears to be invalid.

`valid_padloc_model_basic()` is run automatically upon building or reading a 
padloc model, it does basic type checking but no assessment of gene overlap or 
counts, as at this stage some genes may actually be gene groups. 

```{r, message = FALSE}
valid_padloc_model_basic(models[["SystemA_III"]])
```

While `valid_padloc_model_basic()` returns `TRUE` for `SystemA_III` before 
expansion of gene groups, the model for `SystemA_III` should technically be
invalid, as the `minimum_total` is `3`, but only two types of genes are listed
in total i.e. `SysaA` and `Sya_accessory` (in reality, we know already that 
`Sya_accessory` actually represents two genes, `SyaB` and `SyaC`).

`valid_padloc_model_expanded()` should be run after expanding the gene groups
of a model to verify that each category of genes contains valid values.

For example's sake, `valid_padloc_model_expanded()` fails (as expected) on the 
unexpanded version of `SystemA_III`.

```{r, message = FALSE}
valid_padloc_model_expanded(models[["SystemA_III"]])
```

But it passes (as expected) on the expanded version.

```{r, message = FALSE}
valid_padloc_model_expanded(models_expanded[["SystemA_III"]])
```

A wrapper is provided to test the validity of all system models in a list and 
return the output as a [purrr::safely()] style [base::list()] with components 
`result` and `error`.

```{r, message = FALSE}
validity_report <- report_padloc_model_validity(models)
```

If the model is valid, `result` is `TRUE` and `error` is `NULL`. 

```{r, message = FALSE}
validity_report[["SystemA_I"]]
```

If the model is invalid, `result` is `FALSE` and `error` is an `error`
object that describes the reason the model is invalid.

```{r, message = FALSE}
validity_report[["SystemA_III"]]
```

To return just the error messages, for inspection, use `why_invalid()`.

```{r, message = FALSE}
why_invalid(validity_report)
```
