---
title: "Validating padloc-db data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Validating padloc-db data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = TRUE
)
```

```{r setup}
library(padlocdev)
```

### Expanding HMM metadata table

The raw HMM metadata table read-in by `read_hmm_meta()` can have multiple names
listed in `protein.name` and `secondary.name` (separated by the delimiter `|`). 
To split these assignments into multiple rows, use `expand_hmm_meta()`.

```{r, message = FALSE}
hmm_meta <- padlocdev_example("padloc-db/hmm_meta.txt") |> read_hmm_meta()
```

```{r, message = FALSE}
hmm_meta |> subset(grepl("HamA", protein.name))
```

```{r, message = FALSE}
hmm_meta_expanded <- expand_hmm_meta(hmm_meta)
hmm_meta_expanded |> subset(grepl("HamA", protein.name))
```

The HMM metadata table can be re-collapsed using `collapse_hmm_meta()`.

```{r, message = FALSE}
hmm_meta_collapsed <- collapse_hmm_meta(hmm_meta_expanded)
hmm_meta_collapsed |> subset(grepl("HamA", protein.name))
```

### Expanding secondary gene assignments

Raw system model files can contain references to gene groups a.k.a 
`secondary.name` assignments. Before testing model validity, these gene
groups need to be expanded.

First, read in the data.

```{r, message = FALSE}
model <- padlocdev_example("padloc-db/sys/DRT_class_II.yaml") |> read_padloc_model()
```

The model for `DRT_class_II` has one '`gene`' in `optional_genes` i.e. 
`Drt_class_II` which is actually a group of genes.

```{r, message = FALSE}
model[["core_genes"]]
```

Several genes in the HMM metadata table have been assigned `Drt_class_II` as a 
`secondary.name` to group them together.

```{r, message = FALSE}
hmm_meta_expanded |> subset(secondary.name == "Drt_class_II")
```

Use `expand_gene_groups()` to expand gene groups for a particuar gene category, 
based on the `secondary.name` assignments in the HMM metadata table.

```{r, message = FALSE}
genes <- expand_gene_groups(model, "core_genes", hmm_meta_expanded)
genes
```

These can be assigned back onto the model. Other genes that are listed in the
gene category being expanded, and are not part of a gene group will also get 
carried over.

```{r, message = FALSE}
model[["core_genes"]] <- genes
model[["core_genes"]]
```

A wrapper is provided to expand the gene assignments for all gene categories 
of all system models in a list, and assign them back onto the models.

```{r, message = FALSE}
models <- padlocdev_example("padloc-db/sys") |> multi_read_padloc_model()
models[["DRT_class_II"]][["core_genes"]]
```

```{r, message = FALSE}
models_expanded <- expand_gene_groups_all(models, hmm_meta_expanded)
models_expanded[["DRT_class_II"]][["core_genes"]]
```

### Checking that system models are valid

`valid_padloc_model_basic()` and `valid_padloc_model_expanded()` are used for
assessing model validity. Each function provides useful error information for
fixing a model if it is invalid.

`valid_padloc_model_basic()` is run automatically upon reading a padloc model, 
it does basic type checking but no assessment of duplicated genes, overlap 
between gene categories, or validation of gene number requirements, as at 
this initial stage, some genes may actually be gene groups. 

```{r, message = FALSE}
valid_padloc_model_basic(models[["DRT_class_II"]])
```

While `valid_padloc_model_basic()` returns `TRUE` for `DRT_class_II` before 
expansion of gene groups, the model for `DRT_class_II` should technically be
invalid, as `minimum_core` and `minimum_total` are ``, but only one type of 
genes is listed in total i.e. `Drt_class_II` (in reality, we know already that 
`Drt_class_II` actually represents three genes, `Drt2`, `Drt3a` and `Drt3b`).

`valid_padloc_model_expanded()` should be run after expanding the gene groups
of a model to perform these types of additional validation checks.

For example's sake, `valid_padloc_model_expanded()` fails (as expected) on the 
unexpanded version of `DRT_class_II`, for the reasons mentioned above.

```{r, message = FALSE}
valid_padloc_model_expanded(models[["DRT_class_II"]])
```

But it passes (as expected) on the expanded version.

```{r, message = FALSE}
valid_padloc_model_expanded(models_expanded[["DRT_class_II"]])
```

The wrapper `report_padloc_model_validity()` is provided to test the validity 
of all system models in a list and return the output as a `list` of 
`?purrr::safely`-style sub-`lists` with two components `result` and `error`.

```{r, message = FALSE}
validity_report <- report_padloc_model_validity(models)
```

For each model, if it is valid, `result` is `TRUE` and `error` is `NULL`. 

```{r, message = FALSE}
validity_report[["DRT_class_II"]]
```

If the model is invalid, `result` is `FALSE` and `error` is an 
`?rlang::rlang_error` object that describes the reason the model is invalid.

```{r, message = FALSE}
validity_report[["brex_type_I"]]
```

To return just the error messages for all model in the list, use 
`why_invalid()`.

```{r, message = FALSE}
why_invalid(validity_report)
```

```{r, message = FALSE}
comparison <- compare_hmm_files_hmm_meta(hmm_headers, hmm_meta)
comparison
```

```{r, message = FALSE}
comparison <- compare_sys_files_sys_meta(models, sys_meta)
comparison
```

```{r, message = FALSE}
comparison <- compare_sys_meta_sys_groups(sys_meta, sys_groups)
comparison
```

```{r, message = FALSE}
comparison <- compare_sys_files_hmm_meta(models_expanded, hmm_meta_expanded)
comparison
```

### An example of a broken database

An example of a broken database with various issues has also been included.
First, we'll read in the database files.

```{r, message = FALSE}
path_hmm <- padlocdev_example("padloc-db-broken/hmm")
path_sys <- padlocdev_example("padloc-db-broken/sys")
path_hmm_meta <- padlocdev_example("padloc-db-broken/hmm_meta.txt")
path_sys_meta <- padlocdev_example("padloc-db-broken/sys_meta.txt")
path_sys_groups <- padlocdev_example("padloc-db-broken/sys_groups.txt")

hmms <- multi_read_hmm_header(path_hmm)
models <- multi_read_padloc_model(path_sys)
hmm_meta <- read_hmm_meta(path_hmm_meta)
sys_meta <- read_sys_meta(path_sys_meta)
sys_groups <- read_sys_groups(path_sys_groups)
```
```{r, message = FALSE}
# read_padloc_model_safely <- purrr::safely(read_padloc_model)
# models <- purrr::map(list.files(path_sys, pattern = ".yaml", full.names = TRUE), read_padloc_model_safely)

```

#### Verify that HMM file names match their accession

Before trying to expand anything, lets see if there's anything missing. First, 
we'll check that the HMM file names match their accessions, as this may affect
other stages of validation.

```{r, message = FALSE}
hmm_name_verification <- verify_hmm_names(hmms)
hmm_name_verification
```

Here, we can see that the HMMs with filenames `PDLC03000.hmm` and 
`PDLC02505.hmm` do not have matching accession fields. It's unclear whether the 
filename or the accession fields are incorrect, but we could check whether 
there are mentions of either of these HMMs in the metadata table to 
investigate.

```{r, message = FALSE}
check <- list(
  file_names = hmm_name_verification[["names_mismatch"]][["file_name"]],
  accessions = hmm_name_verification[["names_mismatch"]][["accession_field"]]
)

in_hmm_meta <- purrr::map(check, function(x) subset(hmm_meta, hmm.acc %in% x))
in_hmm_meta
```

Now we can see that the HMM with filename `PDLC02505.hmm` has an entry in the 
HMM metadata table, so the accession is most likely what is incorrect, and 
should be updated to be `PDLC02505`. In addition, the HMM with accession 
`PDLC02511` has an entry in the metadata table, so the filename `PDLC03000.hmm` 
should be updated to be `PDLC02511.hmm`.

If any HMMs listed in the mismatch table did not show up in the metadata table, 
we might deduce that both the filename and the accession are incorrect, or this 
HMM hasn't been added to the metadata table yet (the name mismatch should be 
resolved before adding), or the HMM has been included in the `hmm` directory
in error. Either way, these cases should also be dealt with.

#### Compare the profile HMMs with the HMM metadata table

Next, we'll compare the HMMs with the metadata table, to ensure that all HMMs
have an entry and vice-versa.

```{r, message = FALSE}
comparison <- compare_hmm_files_hmm_meta(hmms, hmm_meta)
comparison
```

Here, we can see that there are two HMMs that exist, but are not mentioned in 
the HMM metadata table: `PDLC04000.hmm` and `PDLC05000.hmm`. There are also 
three HMMs that are mentioned in the metadata table but do not exist: 
`BrxA_00001`, `BrxE_00001`, and `BrxP_00001`.

#### Compare the system models with the system metadata table

Next, we'll compare the system models with the system metadata table, to ensure
that all systems have an entry and vice-versa.

```{r, message = FALSE}
comparison <- compare_sys_files_sys_meta(models, sys_meta)
comparison
```

Here, we can see that four system models do not have entries in the system
metadata table: `brex_other`, `generic_system_A`, `generic_system_B`, and 
`hachiman_type_I`. Additionaly, there are three entries in the metadata table
that do not have corresponding system models: `brex_type_II`, `DRT_type_II`, 
and `hachiman_type_II`.

#### Compare the system metadata table with the system groups table

Next, we'll compare the system metadata table with the system groups table, to
ensure that all system models have been assigned to a group.

```{r, message = FALSE}
comparison <- compare_sys_meta_sys_groups(sys_meta, sys_groups)
comparison
```

Here, we can see that two systems with entries in the metadata table have not 
been assigned system groups: `DRT_class_I` and `hachiman_other`. Additionally, 
two of the systems that were previously identified as having missing entries in
the metadata table have been assigned groups: `brex_other` and 
`hachiman_type_I`. The systems `generic_system_A` and `generic_system_B` do not 
appear here as they do not have entries in the metadata table or the system 
groups table.

#### Compare the system models with the HMM metadata table

Once the above issues have been resolved, we can expand the hmm metadata table
and the system models (for the purposes of this example, we won't be correcting 
the issues here).

```{r, message = FALSE}
hmm_meta_expanded <- expand_hmm_meta(hmm_meta)
models_expanded <- expand_gene_groups_all(models, hmm_meta_expanded)
```

Now we can compare the expanded models with the expanded metadata table to
ensure that all genes mentioned in the models have entries in the metadata
table and vice-versa.

```{r, message = FALSE}
comparison <- compare_sys_files_hmm_meta(models_expanded, hmm_meta_expanded)
comparison
```

Now we've confirmed that all , let's check each of the system models to ensure
that they are actually capable of identifying systems with their given
parameters.

...

